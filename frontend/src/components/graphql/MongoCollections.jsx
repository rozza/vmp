import React from 'react';
import { useHistory } from 'react-router-dom';
import { useGraphQL } from 'graphql-react';
import Table from '@material-ui/core/Table';
import TableBody from '@material-ui/core/TableBody';
import TableCell from '@material-ui/core/TableCell';
import TableContainer from '@material-ui/core/TableContainer';
import TableHead from '@material-ui/core/TableHead';
import TablePagination from '@material-ui/core/TablePagination';
import TableRow from '@material-ui/core/TableRow';
import Container from '@material-ui/core/Container';
import Grid from '@material-ui/core/Grid';
import Paper from '@material-ui/core/Paper';
import Loader from '../Loader';
import { withStyles } from "@material-ui/core/styles";
import { styles } from '../styles';
import { reactOptions } from './reactOptions';


// The query is just a string; no need to use `gql` from `graphql-tag`. The
// special comment before the string allows editor syntax highlighting, Prettier
// formatting and linting. The cache system doesnâ€™t require `__typename` or `id`
// fields to be queried.
const query = /* GraphQL */ `
  {
    collections {
       databaseName
       collectionName
       jsonSchema
       isSchemaAutoGenerated
       uiSchema
     }
  }
`;


const CollectionsGraphQL = ({}) => {

  // Memoization allows the `useGraphQL` hook to avoid work in following renders
  // with the same GraphQL operation.
  const operation = React.useMemo(
    () => ({
      query,
      variables: {
      },
    }),
    []
  );

    // The `useGraphQL` hook can be used for both queries and mutations.
  const { loading, cacheValue: { data, ...errors } = {} } = useGraphQL({
    operation,
    fetchOptionsOverride: reactOptions,
    loadOnMount: true,
    loadOnReload: true,
    loadOnReset: true,
  });

  const classes = withStyles(styles);
  const [page, setPage] = React.useState(0);
  const [rowsPerPage, setRowsPerPage] = React.useState(10);

  const handleChangePage = (event, newPage) => {
    setPage(newPage);
  };

  const handleChangeRowsPerPage = (event) => {
    setRowsPerPage(+event.target.value);
    setPage(0);
  };

  const history = useHistory();

  return (
  <Container maxWidth={false} className={classes.container}>
    <Grid container spacing={3} justify="center">
        <Grid item xs={12} md={8} lg={12}>
          <Paper elevation={3}>
    {data && (
      <>
      <TableContainer className={classes.container}>
        <Table stickyHeader aria-label="sticky table">
          <TableHead>
            <TableRow>
               <TableCell id="db">Database</TableCell>
               <TableCell id="coll">Collection</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {data.collections.slice(page * rowsPerPage, page * rowsPerPage + rowsPerPage).map((row) => {
              return (
                <TableRow hover={true} tabIndex={-1} key={row.databaseName + "." + row.collectionName} onClick={() => history.push
                ("/collection/" + row.databaseName + "/" + row.collectionName)} style={{cursor:'pointer'}}>
                  <TableCell key="db">{row.databaseName}</TableCell>
                  <TableCell key="coll">{row.collectionName}</TableCell>
                </TableRow>
              );
            })}
          </TableBody>
        </Table>
      </TableContainer>
      <TablePagination
        rowsPerPageOptions={[10, 25, 100]}
        component="div"
        count={data.collections.length}
        rowsPerPage={rowsPerPage}
        page={page}
        onChangePage={handleChangePage}
        onChangeRowsPerPage={handleChangeRowsPerPage}
      />
      </>
      )}
    {loading && <Loader />}
        </Paper>
     </Grid>
    </Grid>
  </Container>
  );
}

export default function MongoCollections() {
  return (
    <CollectionsGraphQL />
  );
};
