import React from 'react';
import { useGraphQL } from 'graphql-react';
import Table from '@material-ui/core/Table';
import TableBody from '@material-ui/core/TableBody';
import TableCell from '@material-ui/core/TableCell';
import TableContainer from '@material-ui/core/TableContainer';
import TableHead from '@material-ui/core/TableHead';
import TablePagination from '@material-ui/core/TablePagination';
import TableRow from '@material-ui/core/TableRow';
import Paper from '@material-ui/core/Paper';
import Loader from '../Loader';
import { withStyles } from "@material-ui/core/styles";
import { styles } from '../styles';

// Any GraphQL API can be queried in components, where fetch options for the
// URI, auth headers, etc. can be specified. The `useGraphQL` hook will do less
// work for following renders if `fetchOptionsOverride` is defined outside the
// component, or is memoized using the `React.useMemo` hook within the
// component. Typically it’s exported in a config module for use throughout the
// project. The default fetch options received by the override function are
// tailored to the operation; usually the body is JSON but if there are files in
// the variables it will be a `FormData` instance for a GraphQL multipart
// request.
function fetchOptionsOverride(options) {
  options.url = 'http://localhost:8080/graphql';
}

// The query is just a string; no need to use `gql` from `graphql-tag`. The
// special comment before the string allows editor syntax highlighting, Prettier
// formatting and linting. The cache system doesn’t require `__typename` or `id`
// fields to be queried.
const query = /* GraphQL */ `
  {
    collections {
       databaseName
       collectionName
       jsonSchema
       isSchemaAutoGenerated
       uiSchema
     }
  }
`;


const CollectionsGraphQL = ({}) => {

  // Memoization allows the `useGraphQL` hook to avoid work in following renders
  // with the same GraphQL operation.
  const operation = React.useMemo(
    () => ({
      query,
      variables: {
      },
    }),
    []
  );

    // The `useGraphQL` hook can be used for both queries and mutations.
  const { loading, cacheValue: { data, ...errors } = {} } = useGraphQL({
    operation,
    fetchOptionsOverride: fetchOptionsOverride,
    loadOnMount: true,
    loadOnReload: true,
    loadOnReset: true,
  });

  const classes = withStyles(styles);
  const [page, setPage] = React.useState(0);
  const [rowsPerPage, setRowsPerPage] = React.useState(10);

  const handleChangePage = (event, newPage) => {
    setPage(newPage);
  };

  const handleChangeRowsPerPage = (event) => {
    setRowsPerPage(+event.target.value);
    setPage(0);
  };

  return (
    <Paper className={classes.root}>
    {data && (
      <>
      <TableContainer className={classes.container}>
        <Table stickyHeader aria-label="sticky table">
          <TableHead>
            <TableRow>
               <TableCell id="db">Database</TableCell>
               <TableCell id="coll">Collection</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {data.collections.slice(page * rowsPerPage, page * rowsPerPage + rowsPerPage).map((row) => {
              return (
                <TableRow hover role="checkbox" tabIndex={-1} key={row.databaseName + "." + row.collectionName}>
                  <TableCell key="db">{row.databaseName}</TableCell>
                  <TableCell key="coll">{row.collectionName}</TableCell>
                </TableRow>
              );
            })}
          </TableBody>
        </Table>
      </TableContainer>
      <TablePagination
        rowsPerPageOptions={[10, 25, 100]}
        component="div"
        count={data.collections.length}
        rowsPerPage={rowsPerPage}
        page={page}
        onChangePage={handleChangePage}
        onChangeRowsPerPage={handleChangeRowsPerPage}
      />
      </>
      )}
    {loading && <Loader />}
    </Paper>
  );
}

export default function MongoCollections() {
  return (
    <CollectionsGraphQL />
  );
};
